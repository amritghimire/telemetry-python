{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Iterative Telemetry API Reference","title":"Welcome to Iterative Telemetry"},{"location":"#welcome-to-iterative-telemetry","text":"API Reference","title":"Welcome to Iterative Telemetry"},{"location":"reference/iterative_telemetry/","text":"Iterative Telemetry. IterativeTelemetryLogger Source code in iterative_telemetry/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 class IterativeTelemetryLogger : def __init__ ( self , tool_name , tool_version , enabled : bool = True , url = URL , token = TOKEN , ): self . tool_name = tool_name self . tool_version = tool_version self . enabled = enabled self . url = url self . token = token def send_cli_call ( self , cmd_name : str , ** kwargs ): self . send_event ( \"cli\" , cmd_name , ** kwargs ) def send_event ( self , event_type : str , event_name : str , use_thread : bool = False , use_daemon : bool = True , ** kwargs , ): self . send ( { \"interface\" : event_type , \"action\" : event_name , \"extra\" : kwargs }, use_thread = use_thread , use_daemon = use_daemon , ) def send ( self , payload : Dict [ str , Any ], use_thread : bool = False , use_daemon : bool = True , ): if not self . enabled : return payload . update ( self . _runtime_info ()) if use_thread and use_daemon : raise ValueError ( \"use_thread and use_daemon cannot be true at the same time\" ) impl = self . _send if use_daemon : impl = self . _send_daemon if use_thread : impl = self . _send_thread impl ( payload ) def _send_daemon ( self , payload ): import sys cmd = ( f \"import requests;requests.post(' { self . url } ',\" f \"params= {{ 'token':' { self . token } ' }} ,json= { payload } )\" ) if os . name == \"nt\" : from subprocess import ( CREATE_NEW_PROCESS_GROUP , CREATE_NO_WINDOW , STARTF_USESHOWWINDOW , STARTUPINFO , ) detached_flags = CREATE_NEW_PROCESS_GROUP | CREATE_NO_WINDOW startupinfo = STARTUPINFO () startupinfo . dwFlags |= STARTF_USESHOWWINDOW subprocess . Popen ( # pylint: disable=consider-using-with [ sys . executable , \"-c\" , cmd ], creationflags = detached_flags , close_fds = True , startupinfo = startupinfo , ) elif os . name == \"posix\" : subprocess . Popen ( # pylint: disable=consider-using-with [ sys . executable , \"-c\" , cmd ], close_fds = True , ) else : raise NotImplementedError def _send_thread ( self , payload ): Thread ( target = self . _send , args = [ payload ]) . start () def _send ( self , payload ): try : requests . post ( self . url , params = { \"token\" : self . token }, json = payload , timeout = 2 ) except Exception : # pylint: disable=broad-except logger . debug ( \"failed to send analytics report\" , exc_info = True ) def _runtime_info ( self ): \"\"\" Gather information from the environment where DVC runs to fill a report \"\"\" return { \"tool_name\" : self . tool_name , \"tool_version\" : self . tool_version , # \"scm_class\": _scm_in_use(), ** _system_info (), \"user_id\" : _find_or_create_user_id (), \"group_id\" : _find_or_create_user_id (), # TODO } _runtime_info () Gather information from the environment where DVC runs to fill a report Source code in iterative_telemetry/__init__.py 116 117 118 119 120 121 122 123 124 125 126 127 128 def _runtime_info ( self ): \"\"\" Gather information from the environment where DVC runs to fill a report \"\"\" return { \"tool_name\" : self . tool_name , \"tool_version\" : self . tool_version , # \"scm_class\": _scm_in_use(), ** _system_info (), \"user_id\" : _find_or_create_user_id (), \"group_id\" : _find_or_create_user_id (), # TODO } _find_or_create_user_id () The user's ID is stored on a file under the global config directory. The file should contain a JSON with a \"user_id\" key: {\"user_id\": \"16fd2706-8baf-433b-82eb-8c7fada847da\"} IDs are generated randomly with UUID. Source code in iterative_telemetry/__init__.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def _find_or_create_user_id (): \"\"\" The user's ID is stored on a file under the global config directory. The file should contain a JSON with a \"user_id\" key: {\"user_id\": \"16fd2706-8baf-433b-82eb-8c7fada847da\"} IDs are generated randomly with UUID. \"\"\" import uuid config_dir = user_config_dir ( \"mlem\" , \"Iterative\" ) fname = os . path . join ( config_dir , \"user_id\" ) lockfile = os . path . join ( config_dir , \"user_id.lock\" ) # Since the `fname` and `lockfile` are under the global config, # we need to make sure such directory exist already. os . makedirs ( config_dir , exist_ok = True ) try : with FileLock ( # pylint: disable=abstract-class-instantiated lockfile , timeout = 5 ): try : with open ( fname , encoding = \"utf8\" ) as fobj : user_id = json . load ( fobj )[ \"user_id\" ] except ( FileNotFoundError , ValueError , KeyError ): user_id = str ( uuid . uuid4 ()) with open ( fname , \"w\" , encoding = \"utf8\" ) as fobj : json . dump ({ \"user_id\" : user_id }, fobj ) return user_id except Timeout : logger . debug ( \"Failed to acquire %s \" , lockfile ) return None","title":"Iterative telemetry"},{"location":"reference/iterative_telemetry/#iterative_telemetry.IterativeTelemetryLogger","text":"Source code in iterative_telemetry/__init__.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 class IterativeTelemetryLogger : def __init__ ( self , tool_name , tool_version , enabled : bool = True , url = URL , token = TOKEN , ): self . tool_name = tool_name self . tool_version = tool_version self . enabled = enabled self . url = url self . token = token def send_cli_call ( self , cmd_name : str , ** kwargs ): self . send_event ( \"cli\" , cmd_name , ** kwargs ) def send_event ( self , event_type : str , event_name : str , use_thread : bool = False , use_daemon : bool = True , ** kwargs , ): self . send ( { \"interface\" : event_type , \"action\" : event_name , \"extra\" : kwargs }, use_thread = use_thread , use_daemon = use_daemon , ) def send ( self , payload : Dict [ str , Any ], use_thread : bool = False , use_daemon : bool = True , ): if not self . enabled : return payload . update ( self . _runtime_info ()) if use_thread and use_daemon : raise ValueError ( \"use_thread and use_daemon cannot be true at the same time\" ) impl = self . _send if use_daemon : impl = self . _send_daemon if use_thread : impl = self . _send_thread impl ( payload ) def _send_daemon ( self , payload ): import sys cmd = ( f \"import requests;requests.post(' { self . url } ',\" f \"params= {{ 'token':' { self . token } ' }} ,json= { payload } )\" ) if os . name == \"nt\" : from subprocess import ( CREATE_NEW_PROCESS_GROUP , CREATE_NO_WINDOW , STARTF_USESHOWWINDOW , STARTUPINFO , ) detached_flags = CREATE_NEW_PROCESS_GROUP | CREATE_NO_WINDOW startupinfo = STARTUPINFO () startupinfo . dwFlags |= STARTF_USESHOWWINDOW subprocess . Popen ( # pylint: disable=consider-using-with [ sys . executable , \"-c\" , cmd ], creationflags = detached_flags , close_fds = True , startupinfo = startupinfo , ) elif os . name == \"posix\" : subprocess . Popen ( # pylint: disable=consider-using-with [ sys . executable , \"-c\" , cmd ], close_fds = True , ) else : raise NotImplementedError def _send_thread ( self , payload ): Thread ( target = self . _send , args = [ payload ]) . start () def _send ( self , payload ): try : requests . post ( self . url , params = { \"token\" : self . token }, json = payload , timeout = 2 ) except Exception : # pylint: disable=broad-except logger . debug ( \"failed to send analytics report\" , exc_info = True ) def _runtime_info ( self ): \"\"\" Gather information from the environment where DVC runs to fill a report \"\"\" return { \"tool_name\" : self . tool_name , \"tool_version\" : self . tool_version , # \"scm_class\": _scm_in_use(), ** _system_info (), \"user_id\" : _find_or_create_user_id (), \"group_id\" : _find_or_create_user_id (), # TODO }","title":"IterativeTelemetryLogger"},{"location":"reference/iterative_telemetry/#iterative_telemetry.IterativeTelemetryLogger._runtime_info","text":"Gather information from the environment where DVC runs to fill a report Source code in iterative_telemetry/__init__.py 116 117 118 119 120 121 122 123 124 125 126 127 128 def _runtime_info ( self ): \"\"\" Gather information from the environment where DVC runs to fill a report \"\"\" return { \"tool_name\" : self . tool_name , \"tool_version\" : self . tool_version , # \"scm_class\": _scm_in_use(), ** _system_info (), \"user_id\" : _find_or_create_user_id (), \"group_id\" : _find_or_create_user_id (), # TODO }","title":"_runtime_info()"},{"location":"reference/iterative_telemetry/#iterative_telemetry._find_or_create_user_id","text":"The user's ID is stored on a file under the global config directory. The file should contain a JSON with a \"user_id\" key: {\"user_id\": \"16fd2706-8baf-433b-82eb-8c7fada847da\"} IDs are generated randomly with UUID. Source code in iterative_telemetry/__init__.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 def _find_or_create_user_id (): \"\"\" The user's ID is stored on a file under the global config directory. The file should contain a JSON with a \"user_id\" key: {\"user_id\": \"16fd2706-8baf-433b-82eb-8c7fada847da\"} IDs are generated randomly with UUID. \"\"\" import uuid config_dir = user_config_dir ( \"mlem\" , \"Iterative\" ) fname = os . path . join ( config_dir , \"user_id\" ) lockfile = os . path . join ( config_dir , \"user_id.lock\" ) # Since the `fname` and `lockfile` are under the global config, # we need to make sure such directory exist already. os . makedirs ( config_dir , exist_ok = True ) try : with FileLock ( # pylint: disable=abstract-class-instantiated lockfile , timeout = 5 ): try : with open ( fname , encoding = \"utf8\" ) as fobj : user_id = json . load ( fobj )[ \"user_id\" ] except ( FileNotFoundError , ValueError , KeyError ): user_id = str ( uuid . uuid4 ()) with open ( fname , \"w\" , encoding = \"utf8\" ) as fobj : json . dump ({ \"user_id\" : user_id }, fobj ) return user_id except Timeout : logger . debug ( \"Failed to acquire %s \" , lockfile ) return None","title":"_find_or_create_user_id()"}]}